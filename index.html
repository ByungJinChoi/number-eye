<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<title>XROBO BLE ‚Äî Digit OCR (v5 fixed)</title>
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
<!-- Blockly -->
<script src="https://unpkg.com/blockly/blockly.min.js"></script>
<!-- Tesseract.js v5 (CDN) -->
<script src="https://unpkg.com/tesseract.js@5/dist/tesseract.min.js"></script>
<style>
  :root{
    --pad:10px; --uiScale: 1; --headerH: 64px; --btnH: 36px; --gap: 8px;
    --headerBgTop: #fff7ed; --headerBgBottom: #fffbeb; --headerBorder: #fed7aa;
    --logH: 180px; --blue: #1d4ed8;
    --handleWBase: 22; --handleHBase: 28; --triWBase: 14; --triHBase: 12;
    --handleW: calc(var(--handleWBase) * var(--uiScale) * 1px);
    --handleH: calc(var(--handleHBase) * var(--uiScale) * 1px);
    --triW:    calc(var(--triWBase)    * var(--uiScale) * 1px);
    --triH:    calc(var(--triHBase)    * var(--uiScale) * 1px);
    --linkBar: calc(3 * var(--uiScale) * 1px);
  }
  *{ box-sizing:border-box; } html, body{ height:100%; } body{ margin:0; font-family:system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
  header{ padding:8px 12px; background:linear-gradient(180deg, var(--headerBgTop), var(--headerBgBottom)); border-bottom:1px solid var(--headerBorder); position:relative; z-index:10; }
  #topbar{ display:flex; align-items:center; gap: calc(var(--gap) * var(--uiScale)); flex-wrap: wrap; }
  .title{ font-weight:800; letter-spacing:.2px; color:#7c2d12; margin-right:12px; font-size:calc(18px * var(--uiScale)); }
  .spacer{ flex:1 1 auto; }
  .btn{ height:calc(var(--btnH) * var(--uiScale)); padding:0 calc(12px * var(--uiScale)); border:0; border-radius:calc(10px * var(--uiScale)); display:inline-flex; align-items:center; justify-content:center; font-size:calc(14px * var(--uiScale)); font-weight:600; box-shadow:0 2px 8px rgba(0,0,0,.08); background:#f3f4f6; color:#111827; cursor:pointer; user-select:none; }
  .btn.small{ height: calc(var(--btnH) * var(--uiScale) * .85); padding: 0 calc(10px * var(--uiScale)); font-size: calc(12px * var(--uiScale)); }
  #connectToggle{ background:#2563eb; color:#fff; } #testBtn{ background:#0ea5e9; color:#fff; } #runToggle{ background:#16a34a; color:#fff; } #fsBtn{ background:#111827; color:#fff; }
  .state{ display:inline-flex; align-items:center; gap:calc(6px * var(--uiScale)); height:calc(var(--btnH) * var(--uiScale)); padding:0 calc(6px * var(--uiScale)); font-size:calc(12px * var(--uiScale)); }
  .badgeDot{ width:calc(22px * var(--uiScale)); height:calc(22px * var(--uiScale)); border-radius:50%; display:inline-flex; align-items:center; justify-content:center; font-size:calc(11px * var(--uiScale)); font-weight:800; color:#fff; box-shadow:0 0 0 calc(4px * var(--uiScale)) rgba(0,0,0,.06) inset; }
  .badgeDot.on{ background:#3b82f6; } .badgeDot.off{ background:#ef4444; }
  #main{ display:flex; width:100%; height: calc(100vh - var(--headerH)); }
  #left{ position:relative; flex:1 1 auto; min-width:0; height:100%; display:flex; overflow:visible; }
  #blocklyDiv{ flex:1 1 auto; min-width:0; height:100%; width:100%; }
  #right{ flex:0 0 40%; display:flex; flex-direction:column; background:#fff; margin:8px 8px 8px 0; border:1px solid #e5e7eb; border-left:3px solid var(--blue); border-radius:12px 0 0 12px; box-shadow:0 2px 10px rgba(0,0,0,.04); overflow:hidden; position:relative; }
  #rightTop{ flex:1 1 auto; border-bottom:1px solid #e5e7eb; min-height:120px; background:#0b0f14; color:#fff; display:flex; align-items:center; justify-content:center; padding:0; overflow:hidden; }
  .camWrap{ position:relative; width:100%; height:100%; display:flex; align-items:center; justify-content:center; background:#000; }
  #camVideo{ width:100%; height:100%; object-fit:cover; transform: scaleX(-1); background:#000; }
  .camUi{ position:absolute; right:12px; top:12px; display:flex; gap:8px; align-items:center; z-index:2; }
  .camBadge{ font:700 12px/1 system-ui; color:#fff; padding:.35rem .6rem; border-radius:999px; border:1px solid rgba(255,255,255,.3); background:rgba(0,0,0,.35); backdrop-filter:blur(6px) }
  #focusBox{ position:absolute; left:50%; top:50%; width:22%; aspect-ratio:1/1; transform: translate(-50%,-50%); border:2px solid rgba(255,255,255,.9); border-radius:10px; box-shadow:0 0 0 2px rgba(0,0,0,.25), 0 0 18px rgba(0,255,220,.35); pointer-events:none; z-index:2; opacity:.15; transition: opacity .2s linear, box-shadow .15s ease; }
  #digitReadout{ position:absolute; left:50%; transform:translateX(-50%); bottom:12px; z-index:2; display:inline-flex; align-items:center; gap:.55rem; font:800 13px/1 system-ui; color:#fff; padding:.48rem .8rem; border-radius:999px; border:1px solid rgba(255,255,255,.35); background:rgba(0,0,0,.35); backdrop-filter:blur(6px); }
  #digitReadout .value{ font:900 18px/1.1 ui-monospace, Menlo, Consolas, monospace; padding:2px 8px; border-radius:8px; background:rgba(255,255,255,.12); box-shadow:0 0 0 2px rgba(255,255,255,.18) inset; }
  #rightDivider{ flex:0 0 6px; cursor: row-resize; background: repeating-linear-gradient(90deg, #d1d5db 0, #d1d5db 6px, #e5e7eb 6px, #e5e7eb 12px); }
  #rightBottom{ flex:0 0 var(--logH); display:flex; flex-direction:column; min-height:0; overflow:hidden; padding:calc(10px * var(--uiScale)); background:#0b0f14; color:#d1e4ff; border-top:1px solid #1f2937; }
  #log{ flex:1 1 0; min-height:0; overflow:auto; white-space:pre-wrap; background:#0b0f14; border:1px solid #1f2937; border-radius: calc(8px * var(--uiScale)); padding: calc(10px * var(--uiScale)); font-family: ui-monospace, Menlo, Consolas, monospace; font-size: calc(12px * var(--uiScale)); color:#d1e4ff; }
  #panelHandle{ position:absolute; top: calc(12px * var(--uiScale)); right: 0; z-index:999; width: var(--handleW); height: var(--handleH); background: var(--blue); border: 0; border-radius: calc(6px * var(--uiScale)); box-shadow: 0 2px 8px rgba(0,0,0,.18); cursor:pointer; padding:0; display:none; }
  body.fs-active #main{ height:calc(100vh - var(--headerH)); }
  /* fullscreen overlay (eyes) */
  #playOverlay{ position:fixed; inset:0; background:#000; color:#fff; display:none; z-index:10000; touch-action:none; }
  #playOverlay.show{ display:flex; flex-direction:column; }
  #playOverlay .body{ flex:1 1 auto; display:flex; align-items:center; justify-content:center; background:#000; }
  #eyesStage{ width:100%; height:100%; display:grid; place-items:center; background:#000; }
  .eyes{ display:grid; grid-auto-flow:column; align-items:center; gap:8vmin; }
  .eye{ position:relative; width:25vmin; height:25vmin; border-radius:50%; overflow:hidden; background: radial-gradient(ellipse at 40% 40%, #fff 0 70%, #e9e9e9 100%); box-shadow: 0 1.2vmin 3vmin rgba(0,0,0,.45), inset 0 -0.8vmin 1.6vmin rgba(0,0,0,.12); }
  .pupil{ position:absolute; width:9.6vmin; height:9.6vmin; border-radius:50%; background: radial-gradient(circle at 40% 35%, #222 0 45%, #000 70%, #000 100%); left:50%; top:50%; transform:translate(-50%,-50%); }
  .shine{ position:absolute; width:3.2vmin; height:3.2vmin; border-radius:50%; background: rgba(255,255,255,.85); left:25%; top:22%; filter: blur(0.2vmin); }
  .eyelid{ position:absolute; inset:0; background:#000; transform-origin:top center; transform:scaleY(0); pointer-events:none; }
  #overlayDigitBadge{ position:fixed; left:50%; transform:translateX(-50%); bottom: calc(12px + env(safe-area-inset-bottom)); z-index:10001; display:none; font:700 14px/1 system-ui; color:#fff; padding:.5rem .8rem; border-radius:999px; border:1px solid rgba(255,255,255,.3); background: rgba(0,0,0,.35); backdrop-filter: blur(6px); }
  #overlayDigitBadge .value{ font:900 18px/1.1 ui-monospace, Menlo, Consolas, monospace; padding:2px 8px; border-radius:8px; background:rgba(255,255,255,.12); box-shadow:0 0 0 2px rgba(255,255,255,.18) inset; }
  #eyesCam{ position: fixed; left:0; bottom:0; width:12px; height:12px; opacity:.05; pointer-events:none; z-index:0; transform: scaleX(-1); }
  /* resizer */
  :root{ --rightW: 40%; }
  #hResizer{ flex:0 0 8px; background:linear-gradient(90deg,#e5e7eb,#d1d5db); border-left:1px solid #cbd5e1; border-right:1px solid #cbd5e1; cursor:col-resize; touch-action:none; margin:8px 0; }
</style>
</head>
<body>
<header id="appHeader">
  <div id="topbar">
    <div class="title">XROBO BLE ‚Äî Ïà´Ïûê Ïù∏Ïãù</div>
    <div class="spacer"></div>
    <span class="state"><span id="statusDot" class="badgeDot off">off</span></span>
    <button id="connectToggle" class="btn">Ïó∞Í≤∞</button>
    <button id="testBtn" class="btn" title="ÏΩîÎî© ÌôîÎ©¥ÏóêÏÑú ÌÖåÏä§Ìä∏ Ïã§Ìñâ">ÌÖåÏä§Ìä∏</button>
    <button id="runToggle" class="btn" title="Ï†ÑÏ≤¥ÌôîÎ©¥ ÎààÎèôÏûê Ïã§Ìñâ">Ïã§Ìñâ</button>
    <button id="fsBtn" class="btn" title="Ï†ÑÏ≤¥ÌôîÎ©¥">Ï†ÑÏ≤¥ÌôîÎ©¥</button>
  </div>
</header>

<div id="main">
  <div id="left">
    <div id="blocklyDiv"></div>
    <button id="panelHandle" class="open" title="Ïã§ÌñâÏ∞Ω Îã´Í∏∞"></button>
  </div>
  <div id="hResizer" class="hsplit" title="Ï¢åÏö∞ ÌÅ¨Í∏∞ Ï°∞Ï†à Î∞î"></div>
  <div id="right">
    <div id="rightTop">
      <div class="camWrap" id="camWrap">
        <video id="camVideo" playsinline autoplay muted></video>
        <div id="focusBox"></div>
        <div class="camUi">
          <span id="camBadge" class="camBadge">Cam: off</span>
          <button id="camToggle" class="btn small">Ï∫† ÏºúÍ∏∞</button>
        </div>
        <div id="digitReadout"><span class="label">Ïà´Ïûê</span> <span class="value">‚Äî</span></div>
      </div>
    </div>
    <div id="rightDivider" title="ÎìúÎûòÍ∑∏ÌïòÏó¨ Î°úÍ∑∏ ÎÜíÏù¥ Ï°∞Ï†à"></div>
    <div id="rightBottom">
      <div style="font-size:calc(12px * var(--uiScale));color:#9ca3af;">Ïã§Ìñâ Î°úÍ∑∏</div>
      <div id="log"></div>
    </div>
  </div>
</div>

<!-- Blockly toolbox -->
<xml id="toolbox" style="display:none">
  <category name="Ïù¥Î≤§Ìä∏" colour="#f59e0b">
    <block type="xrobo_start"></block>
  </category>
  <category name="Ï∂úÎ†•" colour="#60a5fa">
    <block type="motor12_dd"><field name="M1">20</field><field name="M2">20</field><field name="MS">500</field></block>
    <block type="motor12_in">
      <value name="M1"><shadow type="math_number"><field name="NUM">20</field></shadow></value>
      <value name="M2"><shadow type="math_number"><field name="NUM">20</field></shadow></value>
      <value name="MS"><shadow type="math_number"><field name="NUM">500</field></shadow></value>
    </block>
    <block type="melody"><field name="PITCH">C4</field>
      <value name="DUR"><shadow type="math_number"><field name="NUM">200</field></shadow></value>
      <value name="WAIT"><shadow type="math_number"><field name="NUM">0</field></shadow></value>
    </block>
    <block type="led_ctrl">
      <field name="TGT">OUT1</field><field name="MODE">BRIGHT</field><field name="VAL">10</field>
    </block>
  </category>
  <category name="Ï†úÏñ¥" colour="#10b981">
    <block type="controls_repeat_ext"><value name="TIMES"><shadow type="math_number"><field name="NUM">3</field></shadow></value></block>
    <block type="wait_seconds"><value name="SEC"><shadow type="math_number"><field name="NUM">1</field></shadow></value></block>
  </category>
</xml>

<!-- Overlay (eyes) -->
<div id="playOverlay" aria-hidden="true">
  <div class="body">
    <video id="eyesCam" playsinline muted autoplay></video>
    <div id="eyesStage" aria-label="Í∑ÄÏó¨Ïö¥ ÎààÎèôÏûê">
      <div class="eyes">
        <div class="eye"><div class="pupil"><div class="shine"></div></div><div class="eyelid"></div></div>
        <div class="eye"><div class="pupil"><div class="shine"></div></div><div class="eyelid"></div></div>
      </div>
    </div>
    <div id="overlayDigitBadge"><span class="label">Ïà´Ïûê</span> <span class="value">‚Äî</span></div>
  </div>
</div>

<script>
/* ===== Blockly setup ===== */
class XroboZelosProvider extends Blockly.zelos.ConstantProvider { constructor(){ super(); this.ADD_START_HATS = true; } }
class XroboZelosRenderer extends Blockly.zelos.Renderer { constructor(){ super('xrobo_zelos'); } makeConstants_(){ return new XroboZelosProvider(); } }
Blockly.blockRendering.register('xrobo_zelos', XroboZelosRenderer);
const XroboTheme = Blockly.Theme.defineTheme('xrobo_theme', { base: Blockly.Themes.Zelos, componentStyles: { startHats: true }});

var ws = Blockly.inject('blocklyDiv', {
  toolbox: document.getElementById('toolbox'),
  renderer: 'xrobo_zelos',
  theme: XroboTheme,
  grid: { spacing:20, length:3, colour:'#eee', snap:true },
  zoom: { controls:true, wheel:true, startScale:1, minScale:0.5, maxScale:2 },
  move: { scrollbars:true, drag:true, wheel:true },
  trashcan: true
});

/* SHIM: quiet deprecated API warnings (Blockly v12) */
(function(){
  try{
    if (Blockly.Workspace && Blockly.Workspace.prototype && Blockly.Workspace.prototype.getAllVariables) {
      Blockly.Workspace.prototype.getAllVariables = function(){
        var vm = this.getVariableMap ? this.getVariableMap() : null;
        return (vm && vm.getAllVariables) ? vm.getAllVariables() : [];
      };
    }
  }catch(e){}
})();

/* ===== Common ===== */
var PINS_OUT=[["OUT1","OUT1"],["OUT2","OUT2"],["OUT3","OUT3"],["OUT4","OUT4"],["OUT5","OUT5"],["OUT6","OUT6"],["OUT7","OUT7"],["OUT8","OUT8"]];
var SPEEDS=Array.from({length:41},(_,i)=>20-i).map(v=>[String(v),String(v)]);
var TIMES100=Array.from({length:10},(_,i)=>100*(i+1)).map(v=>[String(v),String(v)]);
var LED_TGT=[].concat(PINS_OUT,[["CPU","CPU"]]);
var LED_MODE=[["Î∞ùÍ∏∞","BRIGHT"],["Ïà®Ïâ¨Í∏∞","BREATHE"]];
var LED_VALS=Array.from({length:20},(_,i)=>[String(i),String(i)]);

/* ===== Blocks ===== */
const DIGIT_OPTIONS = Array.from({length:10}, (_,i)=>[String(i), 'D'+i]);
Blockly.defineBlocksWithJsonArray([
  { "type":"xrobo_start", "message0":"Ïà´Ïûê %1 Ïù¥ Î≥¥Ïù¥Î©¥",
    "args0":[{ "type":"field_dropdown","name":"DIGIT","options": DIGIT_OPTIONS }],
    "nextStatement":null, "colour":36, "hat":"cap"
  },
  { "type":"motor12_dd","message0":"Î™®ÌÑ∞ M1 %1  M2 %2  ÏãúÍ∞Ñ %3 ms",
    "args0":[{"type":"field_dropdown","name":"M1","options":SPEEDS},{"type":"field_dropdown","name":"M2","options":SPEEDS},{"type":"field_dropdown","name":"MS","options":TIMES100}],
    "previousStatement":null,"nextStatement":null,"inputsInline":true,"colour":210 },
  { "type":"motor12_in","message0":"Î™®ÌÑ∞ M1 %1  M2 %2  ÏãúÍ∞Ñ %3 ms",
    "args0":[{"type":"input_value","name":"M1","check":"Number"},{"type":"input_value","name":"M2","check":"Number"},{"type":"input_value","name":"MS","check":"Number"}],
    "previousStatement":null,"nextStatement":null,"inputsInline":true,"colour":210 },
  { "type":"melody","message0":"Î©úÎ°úÎîî ÏùåÎÜíÏù¥ %1 ÏÜåÎ¶¨ÏãúÍ∞Ñ %2 ms ÎåÄÍ∏∞ÏãúÍ∞Ñ %3 ms",
    "args0":[{"type":"field_dropdown","name":"PITCH","options":(function(){var KR=["ÎèÑ","Î†à","ÎØ∏","Ìåå","ÏÜî","Îùº","Ïãú"], EN=["C","D","E","F","G","A","B"], L=[]; for(var o=4;o<=6;o++) for(var i=0;i<7;i++) L.push([KR[i]+o, EN[i]+o]); return L;})()},
             {"type":"input_value","name":"DUR","check":"Number"},{"type":"input_value","name":"WAIT","check":"Number"}],
    "previousStatement":null,"nextStatement":null,"inputsInline":true,"colour":300 },
  { "type":"led_ctrl","message0":"LED %1 Î™®Îìú %2 Í∞í %3",
    "args0":[{"type":"field_dropdown","name":"TGT","options":LED_TGT},{"type":"field_dropdown","name":"MODE","options":LED_MODE},{"type":"field_dropdown","name":"VAL","options":LED_VALS}],
    "previousStatement":null,"nextStatement":null,"inputsInline":true,"colour":330 },
  { "type":"wait_seconds","message0":"%1 Ï¥à Í∏∞Îã§Î¶¨Í∏∞",
    "args0":[{"type":"input_value","name":"SEC","check":"Number"}],
    "previousStatement":null,"nextStatement":null,"inputsInline":true,"colour":120 }
]);

/* ===== Code builder ===== */
function numFromInput(parent, name, def){ if (def===void 0) def=0;
  var raw = Blockly.JavaScript.valueToCode(parent, name, Blockly.JavaScript.ORDER_NONE);
  var n = Number(raw != null ? raw : ''); return (isFinite(n) ? n : def);
}
function walkNode(b, list){
  if(!b) return;
  switch(b.type){
    case 'motor12_dd':{
      var v1=+b.getFieldValue('M1'),v2=+b.getFieldValue('M2'),ms=+b.getFieldValue('MS');
      list.push({type:'CMD',s:'M12 '+v1+' '+v2+' '+ms}); if(ms>0) list.push({type:'W',args:[ms]}); break; }
    case 'motor12_in':{
      var v1n=numFromInput(b,'M1',0),v2n=numFromInput(b,'M2',0),msn=numFromInput(b,'MS',0);
      list.push({type:'CMD',s:'M12 '+Math.round(v1n)+' '+Math.round(v2n)+' '+Math.round(msn)}); if(msn>0) list.push({type:'W',args:[msn]}); break; }
    case 'melody':{
      var p=b.getFieldValue('PITCH'),dur=numFromInput(b,'DUR',200),wait=numFromInput(b,'WAIT',0);
      list.push({type:'CMD',s:'MEL '+p+' '+Math.round(dur)+' '+Math.round(wait)}); if(wait>0) list.push({type:'W',args:[wait]}); break; }
    case 'led_ctrl':{
      var t=b.getFieldValue('TGT'),m=b.getFieldValue('MODE'),v=+b.getFieldValue('VAL');
      list.push({type:'CMD',s:'LED '+t+' '+m+' '+v}); break; }
    case 'controls_repeat_ext':{
      var times=Math.max(0, numFromInput(b,'TIMES',1));
      var inner=[]; var first=b.getInputTargetBlock('DO'); walkChain(first, inner);
      list.push({type:'FOR',count:times,body:inner}); break; }
    case 'wait_seconds':{
      var s=numFromInput(b,'SEC',1); if(s>0) list.push({type:'W',args:[s*1000]}); break; }
  }
}
function walkChain(start, list){ for(var n=start; n; n=n.getNextBlock()) walkNode(n, list); }
function normalizeProgram(list){
  var out=[]; for(var i=0;i<list.length;i++){
    var ins=list[i];
    if(ins.type==='CMD'){ var prev=out[out.length-1]; if(prev && prev.type==='CMD' && prev.s===ins.s) continue; }
    else if(ins.type==='W'){
      if(!isFinite(ins.args && ins.args[0]) || ins.args[0]<=0) continue;
      var prevw=out[out.length-1]; if(prevw && prevw.type==='W'){ prevw.args[0]+=ins.args[0]; continue; }
    }
    out.push(ins);
  }
  return out;
}
function buildEventPrograms(){
  const programs = { D0:[], D1:[], D2:[], D3:[], D4:[], D5:[], D6:[], D7:[], D8:[], D9:[] };
  var evs = ws.getBlocksByType('xrobo_start', true);
  for(var i=0;i<evs.length;i++){
    var code = evs[i].getFieldValue('DIGIT') || 'D0';
    var chain = evs[i].getNextBlock(); if(!chain) continue;
    var prog=[]; walkChain(chain, prog);
    var norm = normalizeProgram(prog);
    programs[code] = programs[code].concat(norm);
  }
  return programs;
}

/* ===== Header & zoom sync ===== */
function applyHeaderHeight(){
  var px = document.getElementById('appHeader').offsetHeight || 64;
  document.documentElement.style.setProperty('--headerH', px+'px');
  setTimeout(function(){ Blockly.svgResize(ws); }, 60);
}
function applyUiScaleFromWorkspace(){
  var s = Math.max(.7, Math.min(1.6, ws.getScale()));
  document.documentElement.style.setProperty('--uiScale', s);
  applyHeaderHeight();
}
window.addEventListener('resize', applyHeaderHeight);
document.addEventListener('fullscreenchange', applyHeaderHeight);
ws.addChangeListener(function(ev){
  if(ev && ev.type===Blockly.Events.UI && ev.element==='zoom'){ applyUiScaleFromWorkspace(); }
});
setInterval(function(){ applyUiScaleFromWorkspace(); }, 200);
applyUiScaleFromWorkspace();
applyHeaderHeight();

/* ===== BLE (unchanged behavior) ===== */
var SERVICE_UUID=0xFFF0;
var bleDevice=null,bleServer=null,bleService=null,writeChar=null,notifyChar=null;
var isConnected=false, isRunning=false, isFullscreenRun=false;
var $=id=>document.getElementById(id);
var log=function(m){ var L=$('log'); L.textContent+=m+"\\n"; L.scrollTop=L.scrollHeight; };
var dot=$('statusDot');
var btnConnect=$('connectToggle'), btnRun=$('runToggle'), btnTest=$('testBtn');
var enc = s=> new TextEncoder().encode(s);

function resetBleRefs(){ bleDevice=null; bleServer=null; bleService=null; writeChar=null; notifyChar=null; }
function setConnected(v){
  isConnected=v;
  btnConnect.textContent=v?'Ìï¥Ï†ú':'Ïó∞Í≤∞';
  dot.classList.toggle('on',v); dot.classList.toggle('off',!v);
  dot.textContent=v?'on':'off';
  if(!v) setRunning(false);
}
function setRunning(v){
  isRunning=v;
  btnRun.textContent = v ? '‚ñ† Ï†ïÏßÄ' : 'Ïã§Ìñâ';
  btnRun.style.background = v ? '#ef4444' : '#16a34a';
  btnTest.disabled = v;
}
function connectBLE(){
  if(!navigator.bluetooth){ alert('Ïù¥ Î∏åÎùºÏö∞Ï†ÄÎäî Web Bluetooth ÎØ∏ÏßÄÏõêÏûÖÎãàÎã§.'); return; }
  (async function(){
    try{
      var dev = await navigator.bluetooth.requestDevice({ filters:[{ namePrefix:'XROBO' }], optionalServices:[SERVICE_UUID, 0xFFF3, 0xFFF4] });
      try{ if (bleDevice && bleDevice.removeEventListener){ bleDevice.removeEventListener('gattserverdisconnected', onDisconnected); } }catch(e){}
      resetBleRefs(); bleDevice=dev;
      if (bleDevice && bleDevice.addEventListener){ bleDevice.addEventListener('gattserverdisconnected', onDisconnected); }
      bleServer=await bleDevice.gatt.connect();
      bleService=await bleServer.getPrimaryService(SERVICE_UUID);
      try{ writeChar=await bleService.getCharacteristic(0xFFF3);}catch(e){}
      try{ notifyChar=await bleService.getCharacteristic(0xFFF4);}catch(e){}
      if(!writeChar || notifyChar==null){
        var cs=await bleService.getCharacteristics();
        for(var i=0;i<cs.length;i++){
          var ch=cs[i], p=ch.properties||{};
          if(!writeChar && (p.write||p.writeWithoutResponse)) writeChar=ch;
          if(!notifyChar && p.notify) notifyChar=ch;
        }
      }
      if(!writeChar) throw new Error('write ÌäπÏÑ±ÏùÑ Ï∞æÏßÄ Î™ªÌñàÏäµÎãàÎã§.');
      if(notifyChar){
        await notifyChar.startNotifications();
        if (notifyChar.addEventListener){
          notifyChar.addEventListener('characteristicvaluechanged',function(ev){
            try{ var v=new TextDecoder().decode(ev.target.value||new Uint8Array()); log('‚¨ÖÔ∏è '+v.trim()); }catch(e){}
          });
        }
      }
      setConnected(true);
      log('‚úÖ Ïó∞Í≤∞: '+(dev.name||'(Ïù¥Î¶Ñ ÏóÜÏùå)'));
    }catch(e){
      console.error(e); log('‚ùå Ïó∞Í≤∞ Ïã§Ìå®: '+e);
      setConnected(false); resetBleRefs();
    }
  })();
}
function onDisconnected(){ log('üîå Ìï¥Ï†úÎê®'); setConnected(false); resetBleRefs(); }
function disconnectBLE(){ try{ if (bleDevice && bleDevice.gatt) bleDevice.gatt.disconnect(); }catch(e){} setConnected(false); resetBleRefs(); }
$('connectToggle').onclick = ()=> isConnected ? disconnectBLE() : connectBLE();

/* ===== Run/Queue ===== */
var overlay=document.getElementById('playOverlay');
var eventPrograms = {};
var queue = [];
var queueBusy = false;
var cancelToken = 0;

function sendRaw(s){
  if(!writeChar){ log('‚û°Ô∏è(BLE ÎØ∏Ïó∞Í≤∞) '+s); return Promise.resolve(); }
  return writeChar.writeValue(enc(s+'\\n')).then(()=>{ log('‚û°Ô∏è '+s); }).catch(e=>{ log('‚ö†Ô∏è Ï†ÑÏÜ° Ïã§Ìå®: '+e); });
}
async function processQueue(localToken){
  if(queueBusy) return;
  queueBusy = true;
  try{
    while(queue.length && localToken === cancelToken){
      var item = queue.shift();
      await runList(item.list, localToken);
    }
  }finally{ queueBusy = false; }
}
async function runList(list, localToken){
  for(var i=0;i<list.length;i++){
    var ins=list[i];
    if(localToken !== cancelToken) return;
    if(ins.type==='CMD'){ await sendRaw(ins.s); }
    else if(ins.type==='W'){ var ms = (ins.args && ins.args[0]) ? ins.args[0] : 0; await new Promise(r=>setTimeout(r, ms)); }
    else if(ins.type==='FOR'){
      for(var k=0;k<ins.count;k++){ if(localToken !== cancelToken) return; await runList(ins.body, localToken); }
    }
  }
}
function triggerEvent(name){
  if(!isRunning) return;
  var seq = eventPrograms[name];
  if(seq && seq.length){
    queue.push({list: seq});
    var myToken = cancelToken;
    processQueue(myToken);
  }
}
function startTest(){
  if(isRunning) return;
  eventPrograms = buildEventPrograms();
  cancelToken++; queue = [];
  isFullscreenRun = false;
  setRunning(true);
}
let overlayStartedCam = false;
async function startFullRun(){
  if(isRunning) return;
  eventPrograms = buildEventPrograms();
  cancelToken++; queue = [];
  isFullscreenRun = true;
  setRunning(true);
  overlay.classList.add('show'); overlay.setAttribute('aria-hidden','false');
  try{ if(overlay.requestFullscreen) await overlay.requestFullscreen(); }catch(e){}
  overlayStartedCam = !camOn;
  if(!camOn){ try{ await startCam(); }catch(e){ log('‚ö†Ô∏è Ïã§Ìñâ Ï§ë Ïπ¥Î©îÎùº ÏãúÏûë Ïã§Ìå®: '+e); } }
  try{ const eyesCam = document.getElementById('eyesCam'); if(camStream) { eyesCam.srcObject = camStream; await eyesCam.play(); } }catch(e){}
  startOverlayEyes();
}
async function stopRun(){
  cancelToken++; queue=[];
  setRunning(false);
  stopOverlayEyes();
  overlay.classList.remove('show'); overlay.setAttribute('aria-hidden','true');
  isFullscreenRun = false;
  try{ if(document.fullscreenElement) await document.exitFullscreen(); }catch(e){}
  try{ if(writeChar) writeChar.writeValue(enc('S\\n')); }catch(e){}
  if(overlayStartedCam){ stopCam(); overlayStartedCam=false; }
}
btnTest.onclick = ()=> { if(!isRunning) startTest(); };
btnRun.onclick  = ()=> { if(!isRunning) startFullRun(); else stopRun(); };
document.addEventListener('fullscreenchange', ()=>{ if (isFullscreenRun && !document.fullscreenElement){ stopRun(); } });
document.addEventListener('keydown', (e)=>{ if (isFullscreenRun && e.key === 'Escape') stopRun(); });

/* ===== Camera + OCR ===== */
const camWrap   = document.getElementById('camWrap');
const camVideo  = document.getElementById('camVideo');
const camToggle = document.getElementById('camToggle');
const camBadge  = document.getElementById('camBadge');
const focusBox  = document.getElementById('focusBox');
const digitReadout = document.getElementById('digitReadout');
const digitValEl = digitReadout.querySelector('.value');

const LOW_W = 64, LOW_H = 48;
const MASS_MIN = 12000;
const FOCUS_LERP = 0.20;

// OCR params
const OCR_W = 224, OCR_H = 224;
const OCR_INTERVAL_MS = 480;
const OCR_HOLD_MS = 240;
const OCR_MIN_CONF = 55; // ÎÇÆÏ∂∞ÏÑú Ïù∏ÏãùÎ•† Ìñ•ÏÉÅ

let camStream = null, camOn = false, camRAF = null;

const procCvs = document.createElement('canvas');
const procCtx = procCvs.getContext('2d', { willReadFrequently:true });
procCvs.width = LOW_W; procCvs.height = LOW_H;

const ocrCvs = document.createElement('canvas');
const ocrCtx = ocrCvs.getContext('2d', { willReadFrequently:true });
ocrCvs.width = OCR_W; ocrCvs.height = OCR_H;

// second canvas for inverted test
const ocrCvsInv = document.createElement('canvas');
const ocrCtxInv = ocrCvsInv.getContext('2d', { willReadFrequently:true });
ocrCvsInv.width = OCR_W; ocrCvsInv.height = OCR_H;

function toGray(r,g,b){ return (r*0.299 + g*0.587 + b*0.114)|0; }

let activeDigit = null, candDigit = null, candSince = 0;
let fx=0.5, fy=0.5, fxT=0.5, fyT=0.5;

function setCamBadge(t){ camBadge.textContent = 'Cam: ' + t; }
function updateCamUi(){ setCamBadge(camOn ? 'on' : 'off'); camToggle.textContent = camOn ? 'Ï∫† ÎÅÑÍ∏∞' : 'Ï∫† ÏºúÍ∏∞'; }
function updateDigitReadout(v){ digitValEl.textContent = (v==null ? '‚Äî' : String(v)); }

async function startCam(){
  if(camOn) return;
  try{
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode:{ideal:'user'}, width:{ideal:320}, height:{ideal:240}, frameRate:{ideal:30,max:30} },
      audio: false
    });
    camStream = stream; camVideo.srcObject = stream; await camVideo.play();
    camOn = true; updateCamUi(); updateDigitReadout(null);
    await ensureOcr();  // OCR Ï§ÄÎπÑ
    startDetectLoop();
    log('üé• Ïπ¥Î©îÎùº ÏºúÏßê');
  }catch(e){ log('‚ùå Ïπ¥Î©îÎùº Ïã§Ìå®: '+e); }
}
function stopCam(){
  if(!camOn) return;
  try{ camVideo.pause(); }catch(_){}
  if(camVideo.srcObject){ try{ camVideo.srcObject.getTracks().forEach(t=>t.stop()); }catch(_){}
    camVideo.srcObject = null; }
  camStream = null; camOn=false; updateCamUi();
  if(camRAF){ cancelAnimationFrame(camRAF); camRAF=null; }
  activeDigit=candDigit=null; candSince=0; fx=fy=fxT=fyT=0.5;
  focusBox.style.left='50%'; focusBox.style.top='50%'; focusBox.style.opacity='.15';
  updateDigitReadout(null);
  log('üõë Ïπ¥Î©îÎùº Í∫ºÏßê');
}
camToggle.onclick = ()=> camOn ? stopCam() : startCam();

/* === Tesseract.js worker (v5-safe) === */
let ocrWorker = null; let ocrReady = false; let ocrBusy = false; let ocrLastTs = 0;
async function ensureOcr(){
  if(ocrReady) return;
  try{
    log('üß† OCR Ï¥àÍ∏∞Ìôî Ï§ë...');
    try{
      // v5 Ïä§ÌÉÄÏùº: Ïñ∏Ïñ¥Î•º Ïù∏ÏûêÎ°ú Ï†ÑÎã¨ (Promise Î∞òÌôò)
      ocrWorker = await Tesseract.createWorker('eng');
    }catch(err){
      // Íµ¨Î≤ÑÏ†Ñ Ìò∏Ìôò
      ocrWorker = Tesseract.createWorker({ logger: ()=>{} });
      if(ocrWorker && typeof ocrWorker.load === 'function'){
        await ocrWorker.load();
        await ocrWorker.loadLanguage('eng');
        await ocrWorker.initialize('eng');
      }
    }
    if(ocrWorker && ocrWorker.setParameters){
      await ocrWorker.setParameters({
        tessedit_char_whitelist: '0123456789',
        // SINGLE_CHAR (10). ÏùºÎ∂Ä ÌôòÍ≤ΩÏóêÏÑú ÏÉÅÏàòÍ∞Ä ÏóÜÏùÑ Ïàò ÏûàÏúºÎØÄÎ°ú Ïà´Ïûê ÏßÄÏ†ï
        tessedit_pageseg_mode: 10,
        classify_bln_numeric_mode: '1'  // Ïà´Ïûê Ïö∞ÏÑ† Î™®Îìú(ÎØ∏ÏßÄÏõê ÌôòÍ≤ΩÏóêÏÑúÎäî Î¨¥ÏãúÎê®)
      });
    }
    ocrReady = true;
    log('üß† OCR Ï§ÄÎπÑ ÏôÑÎ£å');
  }catch(e){
    log('‚ùå OCR Ï¥àÍ∏∞Ìôî Ïã§Ìå®: '+e);
  }
}

/* ROI from focus (video coords) */
function getRoiRectFromFocus(video, fracW=0.24, fracH=0.24){
  const vw = Math.max(1, video.videoWidth || 320);
  const vh = Math.max(1, video.videoHeight|| 240);
  const cx = Math.round((1 - fx) * (vw - 1));  // mirror
  const cy = Math.round(     fy  * (vh - 1));
  const rw = Math.round(vw * fracW);
  const rh = Math.round(vh * fracH);
  const x0 = Math.max(0, Math.min(vw - rw, cx - Math.floor(rw/2)));
  const y0 = Math.max(0, Math.min(vh - rh, cy - Math.floor(rh/2)));
  return { x:x0, y:y0, w:rw, h:rh, vw, vh };
}

/* Otsu threshold + make both normal & inverted */
function preprocessToOcrCanvas(video, rect){
  ocrCtx.drawImage(video, rect.x, rect.y, rect.w, rect.h, 0, 0, OCR_W, OCR_H);
  const img = ocrCtx.getImageData(0,0, OCR_W, OCR_H);
  const d = img.data;
  // histogram
  const hist = new Uint32Array(256);
  for(let i=0;i<d.length;i+=4){
    const g = toGray(d[i], d[i+1], d[i+2]);
    d[i]=d[i+1]=d[i+2]=g;
    hist[g]++;
  }
  // Otsu
  let sum=0, sumB=0, wB=0, wF=0, mB=0, mF=0, maxVar=-1, th=127, total=OCR_W*OCR_H;
  for(let t=0;t<256;t++) sum += t * hist[t];
  for(let t=0;t<256;t++){
    wB += hist[t]; if(wB===0) continue;
    wF = total - wB; if(wF===0) break;
    sumB += t * hist[t];
    mB = sumB / wB; mF = (sum - sumB) / wF;
    const between = wB * wF * (mB - mF) * (mB - mF);
    if(between > maxVar){ maxVar = between; th = t; }
  }
  // normal bin
  const imgN = ocrCtx.createImageData(OCR_W, OCR_H);
  imgN.data.set(img.data);
  for(let i=0;i<imgN.data.length;i+=4){
    const g = imgN.data[i];
    const v = g < th ? 0 : 255;
    imgN.data[i]=imgN.data[i+1]=imgN.data[i+2]=v; imgN.data[i+3]=255;
  }
  ocrCtx.putImageData(imgN, 0, 0);

  // inverted bin
  const imgI = ocrCtxInv.createImageData(OCR_W, OCR_H);
  for(let i=0;i<img.data.length;i+=4){
    const g = img.data[i];
    const v = g > th ? 0 : 255;
    imgI.data[i]=imgI.data[i+1]=imgI.data[i+2]=v; imgI.data[i+3]=255;
  }
  ocrCtxInv.putImageData(imgI, 0, 0);
}

/* do OCR on both canvases, pick better */
async function recognizeDigitFromPrepared(){
  // try normal then inverted; pick higher confidence
  let best = null;
  const res1 = await ocrWorker.recognize(ocrCvs).catch(()=>null);
  if(res1 && res1.data){
    let b=null, c=-1;
    const syms = res1.data.symbols || [];
    for(const s of syms){
      const ch=(s.text||'').trim();
      if(/^[0-9]$/.test(ch) && s.confidence>c){ c=s.confidence; b=ch; }
    }
    if(!b && typeof res1.data.text==='string'){ const m=res1.data.text.match(/[0-9]/); if(m){ b=m[0]; c=res1.data.confidence||0; } }
    if(b!=null) best={digit:b, conf:Math.round(c)};
  }
  const res2 = await ocrWorker.recognize(ocrCvsInv).catch(()=>null);
  if(res2 && res2.data){
    let b=null, c=-1;
    const syms = res2.data.symbols || [];
    for(const s of syms){
      const ch=(s.text||'').trim();
      if(/^[0-9]$/.test(ch) && s.confidence>c){ c=s.confidence; b=ch; }
    }
    if(!b && typeof res2.data.text==='string'){ const m=res2.data.text.match(/[0-9]/); if(m){ b=m[0]; c=res2.data.confidence||0; } }
    if(b!=null){
      if(!best || c > best.conf) best={digit:b, conf:Math.round(c)};
    }
  }
  return best;
}

async function runOcrOnVideo(video){
  if(!ocrReady || ocrBusy) return null;
  const now = performance.now();
  if(now - ocrLastTs < OCR_INTERVAL_MS) return null;
  ocrLastTs = now;
  const rect = getRoiRectFromFocus(video);
  preprocessToOcrCanvas(video, rect);
  try{
    ocrBusy = true;
    // pulse focus box to show OCR timing
    focusBox.style.boxShadow = '0 0 0 2px rgba(0,0,0,.25), 0 0 22px rgba(0,255,150,.65)';
    setTimeout(()=>{ focusBox.style.boxShadow = '0 0 0 2px rgba(0,0,0,.25), 0 0 18px rgba(0,255,220,.35)'; }, 120);
    const out = await recognizeDigitFromPrepared();
    ocrBusy = false;
    if(out && out.digit!=null && out.conf >= OCR_MIN_CONF){ return out; }
  }catch(e){ ocrBusy = false; }
  return null;
}

/* detect loop (panel) */
function startDetectLoop(){
  const step = async ()=>{
    const runOcr = !isFullscreenRun;
    if(!camOn || camVideo.readyState < 2){ camRAF = requestAnimationFrame(step); return; }

    // motion-based focus
    procCtx.drawImage(camVideo, 0, 0, LOW_W, LOW_H);
    const frame = procCtx.getImageData(0,0,LOW_W,LOW_H);
    const data = frame.data;
    if (!step.prevGray) step.prevGray = new Uint8ClampedArray(LOW_W*LOW_H);
    let mass=0, sx=0, sy=0;
    for(let y=0, i=0, p=0; y<LOW_H; y++){
      for(let x=0; x<LOW_W; x++, i++){
        const r = data[p++], g = data[p++], b = data[p++]; p++;
        const gray = toGray(r,g,b);
        const d = Math.abs(gray - step.prevGray[i]);
        step.prevGray[i] = gray;
        if (d>0){ sx += x * d; sy += y * d; mass += d; }
      }
    }
    if (mass > MASS_MIN){
      const cx = sx / mass, cy = sy / mass;
      fxT = 1 - (cx / (LOW_W-1));
      fyT =      (cy / (LOW_H-1));
      focusBox.style.opacity = '1';
    }else{
      focusBox.style.opacity = '.15';
    }
    fx += (fxT-fx)*FOCUS_LERP; fy += (fyT-fy)*FOCUS_LERP;
    focusBox.style.left = (fx*100).toFixed(1)+'%';
    focusBox.style.top  = (fy*100).toFixed(1)+'%';

    if(runOcr){
      const out = await runOcrOnVideo(camVideo);
      const now = performance.now();
      let frameDigit = null;
      if(out && out.digit!=null){ frameDigit = String(out.digit); }
      if (candDigit !== frameDigit){ candDigit = frameDigit; candSince = now; }
      if ((now - candSince) >= OCR_HOLD_MS && activeDigit !== frameDigit){
        activeDigit = frameDigit;
        updateDigitReadout(activeDigit);
        if (activeDigit!=null){
          log('üéØ Ïà´Ïûê Í∞êÏßÄ(ROI): '+activeDigit); triggerEvent('D'+activeDigit);
        }else{ log('‚óΩ Ïà´Ïûê ÏóÜÏùå'); }
      }
    }
    camRAF = requestAnimationFrame(step);
  };
  camRAF = requestAnimationFrame(step);
}

/* ===== Overlay eyes (uses same OCR pipeline on eyesCam) ===== */
const overlayEl = document.getElementById('playOverlay');
const overlayDigitBadge = document.getElementById('overlayDigitBadge');
const overlayDigitVal = overlayDigitBadge.querySelector('.value');
const eyesCam = document.getElementById('eyesCam');
const ovEyes = [...document.querySelectorAll('#playOverlay .eye')];
const ovPupils = [...document.querySelectorAll('#playOverlay .pupil')];
let eyesRAF = null; let ovPrevGray = null;
let ovCurrent = {x:0, y:0}, ovTarget = {x:0, y:0};
let ovActiveDigit = null, ovCandDigit = null, ovCandSince = 0;

function overlayShowDigit(d){ if (d==null){ overlayDigitBadge.style.display='none'; return; } overlayDigitVal.textContent = String(d); overlayDigitBadge.style.display='inline-flex'; }
function renderPupils(nx, ny){
  ovEyes.forEach((eye, i) => {
    const rect = eye.getBoundingClientRect();
    const rEye = Math.min(rect.width, rect.height)/2;
    const limit = rEye * 0.32;
    let dx = nx * limit, dy = ny * limit;
    const dist = Math.hypot(dx,dy);
    if (dist>limit){ const r = limit/dist; dx*=r; dy*=r; }
    ovPupils[i].style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
  });
}

function startOverlayEyes(){
  if(eyesRAF) cancelAnimationFrame(eyesRAF);
  ovPrevGray = null; overlayShowDigit(null);
  function loop(){
    if(!isRunning || !isFullscreenRun){ eyesRAF = requestAnimationFrame(loop); return; }
    if(!eyesCam || eyesCam.readyState < 2){ eyesRAF = requestAnimationFrame(loop); return; }

    // motion ‚Üí gaze
    const eProc = startOverlayEyes._eProc || (startOverlayEyes._eProc = document.createElement('canvas'));
    const eCtx  = startOverlayEyes._eCtx  || (startOverlayEyes._eCtx  = eProc.getContext('2d', { willReadFrequently:true }));
    eProc.width = LOW_W; eProc.height = LOW_H;
    eCtx.drawImage(eyesCam, 0, 0, LOW_W, LOW_H);
    const img = eCtx.getImageData(0,0,LOW_W,LOW_H);
    const data = img.data;
    if (!ovPrevGray) ovPrevGray = new Uint8ClampedArray(LOW_W*LOW_H);
    let mass=0, sx=0, sy=0;
    for (let y=0, i=0, p=0; y<LOW_H; y++){
      for (let x=0; x<LOW_W; x++, i++){
        const r = data[p++], g = data[p++], b = data[p++]; p++;
        const gray = toGray(r,g,b);
        const d = Math.abs(gray - ovPrevGray[i]);
        ovPrevGray[i] = gray;
        if (d>0){ sx += x * d; sy += y * d; mass += d; }
      }
    }
    if (mass > MASS_MIN){
      let nx = -((sx/mass) - (LOW_W/2)) / (LOW_W/2);
      let ny =  ((sy/mass) - (LOW_H/2)) / (LOW_H/2);
      const dead=0.06; nx = Math.abs(nx)<dead ? 0 : nx; ny = Math.abs(ny)<dead ? 0 : ny;
      ovTarget.x = Math.max(-1, Math.min(1, nx*1.2));
      ovTarget.y = Math.max(-1, Math.min(1, ny*1.2));
    }else{
      ovTarget.x *= 0.985; ovTarget.y *= 0.985;
    }
    ovCurrent.x = ovCurrent.x + (ovTarget.x - ovCurrent.x)*0.20;
    ovCurrent.y = ovCurrent.y + (ovTarget.y - ovCurrent.y)*0.20;
    renderPupils(ovCurrent.x, ovCurrent.y);

    // OCR (fullscreen loop)
    (async ()=>{
      const out = await runOcrOnVideo(eyesCam);
      const now = performance.now();
      let frameDigit = null;
      if(out && out.digit!=null){ frameDigit = String(out.digit); }
      if (ovCandDigit !== frameDigit){ ovCandDigit = frameDigit; ovCandSince = now; }
      if ((now - ovCandSince) >= OCR_HOLD_MS && ovActiveDigit !== frameDigit){
        ovActiveDigit = frameDigit;
        overlayShowDigit(ovActiveDigit);
        if (ovActiveDigit!=null){ triggerEvent('D'+ovActiveDigit); }
      }
    })();

    eyesRAF = requestAnimationFrame(loop);
  }
  eyesRAF = requestAnimationFrame(loop);
}
function stopOverlayEyes(){ if(eyesRAF){ cancelAnimationFrame(eyesRAF); eyesRAF=null; } ovPrevGray=null; overlayShowDigit(null); }

/* ===== Resizer ===== */
(function(){
  var res = document.getElementById('hResizer');
  var main = document.getElementById('main');
  var right = document.getElementById('right');
  if(!res || !main || !right) return;
  var dragging=false, startX=0, startW=0, rafId=0, maxW=0;
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function computeMax(){ var rect = main.getBoundingClientRect(); var barW = res.getBoundingClientRect().width || 8; maxW = Math.max(0, rect.width - barW); return maxW; }
  function onDown(clientX){ dragging=true; startX=clientX; startW=right.getBoundingClientRect().width; computeMax(); document.body.classList.add('hs-resizing'); }
  function applyWidth(newW){ newW = clamp(newW, 0, maxW); document.documentElement.style.setProperty('--rightW', newW + 'px'); cancelAnimationFrame(rafId); rafId = requestAnimationFrame(function(){ try{ if (window.Blockly && typeof Blockly.svgResize==='function' && window.ws) { Blockly.svgResize(ws); } }catch(e){} }); }
  function onMove(clientX){ if(!dragging) return; var dx = clientX - startX; var newW = startW - dx; applyWidth(newW); }
  function onUp(){ dragging=false; document.body.classList.remove('hs-resizing'); }
  res.addEventListener('mousedown', function(e){ e.preventDefault(); onDown(e.clientX); });
  window.addEventListener('mousemove', function(e){ onMove(e.clientX); });
  window.addEventListener('mouseup', onUp);
  res.addEventListener('touchstart', function(e){ if(!e.touches || !e.touches[0]) return; e.preventDefault(); onDown(e.touches[0].clientX); }, {passive:false});
  window.addEventListener('touchmove', function(e){ if(!e.touches || !e.touches[0]) return; onMove(e.touches[0].clientX); }, {passive:false});
  window.addEventListener('touchend', onUp);
  document.body.classList.remove('panel-collapsed');
  window.addEventListener('resize', function(){ var cur = right.getBoundingClientRect().width; var mx = computeMax(); if(cur > mx) applyWidth(mx); });
})();

/* ===== Fullscreen button ===== */
var fsBtn=document.getElementById('fsBtn');
async function enterFS(){ var el=document.documentElement; if(el.requestFullscreen) await el.requestFullscreen(); }
async function exitFS(){ if(document.fullscreenElement && document.exitFullscreen) await document.exitFullscreen(); }
function syncFSLabel(){
  var a = !!document.fullscreenElement;
  document.body.classList.toggle('fs-active', a);
  fsBtn.textContent = a ? 'ÌôîÎ©¥Ï∂ïÏÜå' : 'Ï†ÑÏ≤¥ÌôîÎ©¥';
  fsBtn.title = a ? 'ÌôîÎ©¥ Ï∂ïÏÜåÎ°ú Ï†ÑÌôò' : 'Ï†ÑÏ≤¥ÌôîÎ©¥ÏúºÎ°ú Ï†ÑÌôò';
  applyHeaderHeight();
}
fsBtn.onclick=async function(){ if(document.fullscreenElement) await exitFS(); else await enterFS(); };
document.addEventListener('fullscreenchange', syncFSLabel);
syncFSLabel();
</script>
</body>
</html>
